<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Atlas</title>
<link href="https://cdn.jsdelivr.net/npm/remixicon/fonts/remixicon.css" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box;font-family:'Inter',sans-serif}
  body{display:flex;justify-content:center;align-items:center;height:100vh;background:#0d0d0d;color:#fff}
  .chat-wrapper{width:100%;max-width:650px;height:650px;border-radius:20px;background:#111;display:flex;flex-direction:column;overflow:hidden;position:relative}
  .chat-header{padding:16px;font-size:1.5rem;font-weight:700}
  .chat-messages{flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:12px}
  .msg{max-width:80%;padding:12px 16px;background:#181818;border-radius:14px;opacity:0;transform:translateY(6px);transition:0.18s ease-out;word-wrap:break-word}
  .msg.show{opacity:1;transform:translateY(0)}
  .user{align-self:flex-end;background:#1f1f1f;color:#fff;border-bottom-right-radius:4px}
  .bot{align-self:flex-start;background:#181818;color:#fff;border-bottom-left-radius:4px}
  /* typing dots */
  .typing-dots{display:flex;gap:6px;align-items:center}
  .dot{width:9px;height:9px;border-radius:50%;background:#3ea6ff;opacity:0.32;animation:blink 1s infinite}
  .dot:nth-child(2){animation-delay:.18s}
  .dot:nth-child(3){animation-delay:.36s}
  @keyframes blink{0%,100%{opacity:.32}50%{opacity:1}}
  /* input */
  .chat-input{padding:12px 14px;background:#111;border-top:1px solid #222;display:flex;align-items:center;gap:10px}
  #userInput{flex:1;padding:12px 18px;border-radius:25px;border:none;background:#1a1a1a;color:#fff;font-size:15px;outline:none;transition:0.18s}
  #sendBtn{width:46px;height:46px;border-radius:50%;border:none;background:#3ea6ff;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:0;transform:scale(.75);transition:0.22s}
  #sendBtn.show{opacity:1;transform:scale(1)}
  #sendBtn:hover{background:#67bbff}
  /* scroll behavior */
  .chat-messages::-webkit-scrollbar{width:8px}
  .chat-messages::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.04);border-radius:8px}
</style>
</head>
<body>
  <div class="chat-wrapper" role="application" aria-label="Atlas chat">
    <div class="chat-header">Atlas</div>

    <div class="chat-messages" id="chatMessages" aria-live="polite"></div>

    <div class="chat-input">
      <input id="userInput" type="text" placeholder="Message Atlas..." aria-label="Message input" />
      <button id="sendBtn" aria-label="Send message"><i class="ri-send-plane-line" style="font-size:1.25rem"></i></button>
    </div>
  </div>

<script>
const backendURL = "https://atlas-backend-roi5.onrender.com/chat";
const chatMessages = document.getElementById('chatMessages');
const userInput = document.getElementById('userInput');
const sendBtn = document.getElementById('sendBtn');

/* helper: append a normal message element */
function appendMessage(text, sender){
  const el = document.createElement('div');
  el.className = `msg ${sender}`;
  el.innerText = text;
  chatMessages.appendChild(el);
  // small delay to allow transition
  requestAnimationFrame(()=>el.classList.add('show'));
  chatMessages.scrollTop = chatMessages.scrollHeight;
  return el;
}

/* show typing dots and return the element (we will reuse it) */
function createTypingElement(){
  const wrap = document.createElement('div');
  wrap.className = 'msg bot';
  wrap.id = 'typing'; // keep id so we can find it
  wrap.innerHTML = `<div class="typing-dots" aria-hidden="true">
    <div class="dot"></div><div class="dot"></div><div class="dot"></div>
  </div>`;
  chatMessages.appendChild(wrap);
  // ensure the fade-in runs
  requestAnimationFrame(()=>wrap.classList.add('show'));
  chatMessages.scrollTop = chatMessages.scrollHeight;
  return wrap;
}

/* Smooth word-by-word typing using the typing element itself */
async function botReply(userMessage){
  // Show typing dots and keep the element in DOM until we start typing
  const typingEl = createTypingElement();

  try {
    const res = await fetch(backendURL, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ message: userMessage })
    });

    const data = await res.json();
    const botText = (data && data.reply) ? data.reply : "Sorry, I didn't get that.";

    // Now reuse typingEl as the message container for word-by-word typing.
    // Replace its innerHTML (preserve element to avoid visual gap).
    const words = botText.split(/\s+/);
    let i = 0;

    // Clear content but keep the element visible (so dots won't flash away)
    // We'll progressively set innerText to words[0..i]
    // Use a tiny delay so UI shows the transition from dots -> first word smoothly.
    // Important: do NOT remove the element before the first word appears.
    const TYPE_DELAY = 160; // ms per word, tuned for smoothness

    function typeNext(){
      if(i < words.length){
        // set text to first (i+1) words joined by space
        typingEl.textContent = words.slice(0, i+1).join(' ');
        // ensure it has the show class
        typingEl.classList.add('show');
        chatMessages.scrollTop = chatMessages.scrollHeight;
        i++;
        setTimeout(typeNext, TYPE_DELAY);
      } else {
        // finished: ensure final state (already text content)
        // remove id so future createTypingElement can use the id
        typingEl.id = '';
      }
    }

    // start typing on next animation frame to give the browser time to reflow after replacing innerHTML
    requestAnimationFrame(()=> setTimeout(typeNext, 60));
  } catch (err) {
    // If fetch failed, convert typing element into an error message
    if(typingEl){
      typingEl.textContent = "Connection error.";
      typingEl.classList.add('show');
      typingEl.id = '';
    } else {
      appendMessage("Connection error.", "bot");
    }
    console.error(err);
  } finally {
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
}

/* send logic */
function sendMessage(){
  const text = userInput.value.trim();
  if(!text) return;
  appendMessage(text, 'user');
  userInput.value = '';
  sendBtn.classList.remove('show');

  // kick the bot reply
  botReply(text);
}

/* events */
sendBtn.addEventListener('click', sendMessage);
userInput.addEventListener('keypress', e => { if(e.key === 'Enter') sendMessage(); });
userInput.addEventListener('input', () => {
  if(userInput.value.trim()) sendBtn.classList.add('show');
  else sendBtn.classList.remove('show');
});

/* accessibility: allow focus+enter for send button */
sendBtn.addEventListener('keydown', e => { if(e.key === 'Enter') sendMessage(); });

/* optional: keep the input focused on load */
window.addEventListener('load', () => userInput.focus());
</script>
</body>
</html>
